# Practice

## What will you do to handle generic / arbitrary json format ?

### 方法 1: 建議仍以明定結構為首要

我認為仍應明確定義兩邊溝通結構，且介接第三方服務通常亦為已知結構，應該較無需轉換欄位名稱需求，且通常讀入後就會直接使用了。

- 優點：正規做法。
- 缺點：需耗時間定義結構，可能需分別定義 輸入/輸出 結構，或自訂 `UnmarshalJSON \ MarshalJSON` 方法。

### 方法 2: 輸出可透過 `convert.Naming` 方法動態調整結構 (開發中)

因為我平時工作亦有類似，主要是像 `cors / config.go` 寫法一樣，等於需定義兩個結構讓它轉換，雖然實作上不會花太多時間，但仍然繁瑣。

為了解決此問題，我給自己增加一點挑戰難度，寫起來後我自己也可以使用，而且由此練習 reflect 用法，構想略以：

1. 結構定義上加入自訂標籤 `naming`，每個欄位可以獨立定義需轉換的欄位命名規則，當然亦可以不定義統一指定轉換。
2. 透過反射 `reflect` 來動態產生新的結構，讀取 `naming` 後轉換為 `json` 標籤，並將舊結構映射至新結構。
3. 將新結構直接透過 `json.Marshal` 轉換，即可序列化出轉換過之 JSON。

目前還差在 `[]*cors.Rule` 部分尚未解決，思考應該先建立好結構後再填入值，需再花時間研究。

- 優點：
  - 具方法 1 優點，為程式內部已知結構。
  - 可更彈性且動態得調整 JSON 輸入 / 輸出欄位命名樣式。
- 缺點：頻繁使用時可能有效能問題；但應該可以把動態結構緩存起來複用。

### 方法 3: 使用 `map[string]interface{}` 接收所有資料

如為旨揭任意結構，可能也還是只能使用 map[string]interface{} 弱型別接收所有鍵 / 值資料，只是接收後如需在程式內部使用，需逐一斷言且型態，增加程式運作風險且可讀性較差，我個人盡量避免使用此種做法。

- 優點：容易對其鍵值做處理。
- 缺點：使用時需逐一斷言其欄位型態，增加程式運作風險。

## OAuth2

### What is OAuth2 ?

`OAuth2` 主要負責 `Authorization` 授權驗證，用戶端透過持有驗證伺服器或憑證中心派發的令牌或憑證，向相關服務器請求提供服務，服務器可以根據其授權範圍 `scope` 提供服務。

### If need to explain to 3rd party developer to allow them to access your api, what will you do ?

首先會研究 `Ory Hydra` 開源專案，並架設一部 OAuth2 及 OpenID Connect 伺服器，使用 OpenID Connect 提供 `Authentication` 身分驗證並簽發憑證予用戶，用戶請求第三方提供服務時，開發者可呼叫驗證伺服器的 API，驗證該憑證是否合法後，開發者及用戶可透過 OAuth2 憑證請求在其權限範圍內的開放資料，如用戶授權範圍個人資料，即可進行單一簽入。

我在使用 Google 社群帳號的經驗中，用戶端須透過 `Google Identity` 進行身分驗證並取得 Google 簽發的 `Token`，用戶可夾帶 `Token` 向第三方請求服務時，第三方可透過 Goolge API 驗證 `Token` 上的數位簽章是否合法，合法後可使用夾帶的帳號資訊做單一簽入，用戶在請求第三方服務時，第三方可以轉換成內部服務令牌或直接連接用戶 Google 服務。
